//
// GENERATED CODE, DO NOT EDIT THIS FILE!
//
// Generated by ComponentGenerator for Transfer11.  ISO2002 ID# _NJMYgfpeEeCPwaG9zjUPNQ.
//

using BeneficialStrategies.Iso20022.Choices;
using BeneficialStrategies.Iso20022.ExternalSchema;
using BeneficialStrategies.Iso20022.UserDefined;
using System.Xml;
using System.Xml.Linq;

namespace BeneficialStrategies.Iso20022.Components;

/// <summary>
/// Parameters applied to the settlement of a security transfer.
/// </summary>
public partial record Transfer11
     : IIsoXmlSerilizable<Transfer11>
{
    #nullable enable
    
    /// <summary>
    /// Unique and unambiguous identifier for a transfer instruction, as assigned by the instructing party.
    /// </summary>
    public required IsoMax35Text TransferReference { get; init; } 
    /// <summary>
    /// Unique and unambiguous investor's identification of a transfer. This reference can typically be used in a hub scenario to give the reference of the transfer as assigned by the underlying client.
    /// </summary>
    public IsoMax35Text? ClientReference { get; init; } 
    /// <summary>
    /// Unambiguous identification of the transfer allocated by the counterparty.
    /// </summary>
    public AdditionalReference2? CounterpartyReference { get; init; } 
    /// <summary>
    /// Identifies the business process in which the actors are involved. This is important to trigger the right business process, according to the market business model, which may require matching instructions in a CSD environment (double leg process) or not (single leg process).
    /// </summary>
    public BusinessFlowType1Code? BusinessFlowType { get; init; } 
    /// <summary>
    /// Identifies in which date the investor signed the transfer order form.
    /// </summary>
    public IsoISODate? TransferOrderDateForm { get; init; } 
    /// <summary>
    /// Identifies the transfer reason.
    /// </summary>
    public TransferReason1? TransferReason { get; init; } 
    /// <summary>
    /// Identifies whether or not saving plan or withdrawal or switch plan are included in the holdings.
    /// </summary>
    public SimpleValueList<HoldingsPlanType1Code> HoldingsPlanType { get; init; } = [];
    /// <summary>
    /// Information related to the financial instrument to be withdrawn.
    /// </summary>
    public required FinancialInstrument13 FinancialInstrumentDetails { get; init; } 
    /// <summary>
    /// Total quantity of securities to be transferred, expressed in a number of units or a percentage rate.
    /// </summary>
    public required Quantity13Choice_ Quantity { get; init; } 
    /// <summary>
    /// Information about the units to be transferred.
    /// </summary>
    public Unit3? UnitsDetails { get; init; } 
    /// <summary>
    /// Indicates the rounding direction applied to nearest unit.
    /// </summary>
    public RoundingDirection2Code? Rounding { get; init; } 
    /// <summary>
    /// Value of a security, as booked in an account. Book value is often different from the current market value of the security.
    /// </summary>
    public IsoActiveOrHistoricCurrencyAnd13DecimalAmount? AveragePrice { get; init; } 
    /// <summary>
    /// Identifies the currency to be used to transfer the holdings.
    /// </summary>
    public CurrencyCode? TransferCurrency { get; init; } 
    /// <summary>
    /// Indicates whether the transfer results in a change of beneficial owner.
    /// </summary>
    public IsoYesNoIndicator? OwnAccountTransferIndicator { get; init; } 
    /// <summary>
    /// Additional specific settlement information for non-regulated traded funds.
    /// </summary>
    public IsoMax350Text? NonStandardSettlementInformation { get; init; } 
    
    #nullable disable
    
    
    /// <summary>
    /// Used to format the various primative types during serialization.
    /// </summary>
    public static SerializationFormatter SerializationFormatter { get; set; } = SerializationFormatter.GlobalInstance;
    
    /// <summary>
    /// Serializes the state of this record according to Iso20022 specifications.
    /// </summary>
    public void Serialize(XmlWriter writer, string xmlNamespace)
    {
        writer.WriteStartElement(null, "TrfRef", xmlNamespace );
        writer.WriteValue(SerializationFormatter.IsoMax35Text(TransferReference)); // data type Max35Text System.String
        writer.WriteEndElement();
        if (ClientReference is IsoMax35Text ClientReferenceValue)
        {
            writer.WriteStartElement(null, "ClntRef", xmlNamespace );
            writer.WriteValue(SerializationFormatter.IsoMax35Text(ClientReferenceValue)); // data type Max35Text System.String
            writer.WriteEndElement();
        }
        if (CounterpartyReference is AdditionalReference2 CounterpartyReferenceValue)
        {
            writer.WriteStartElement(null, "CtrPtyRef", xmlNamespace );
            CounterpartyReferenceValue.Serialize(writer, xmlNamespace);
            writer.WriteEndElement();
        }
        if (BusinessFlowType is BusinessFlowType1Code BusinessFlowTypeValue)
        {
            writer.WriteStartElement(null, "BizFlowTp", xmlNamespace );
            writer.WriteValue(BusinessFlowTypeValue.ToString()); // Enum value
            writer.WriteEndElement();
        }
        if (TransferOrderDateForm is IsoISODate TransferOrderDateFormValue)
        {
            writer.WriteStartElement(null, "TrfOrdrDtForm", xmlNamespace );
            writer.WriteValue(SerializationFormatter.IsoISODate(TransferOrderDateFormValue)); // data type ISODate System.DateOnly
            writer.WriteEndElement();
        }
        if (TransferReason is TransferReason1 TransferReasonValue)
        {
            writer.WriteStartElement(null, "TrfRsn", xmlNamespace );
            TransferReasonValue.Serialize(writer, xmlNamespace);
            writer.WriteEndElement();
        }
        writer.WriteStartElement(null, "HldgsPlanTp", xmlNamespace );
        writer.WriteValue(HoldingsPlanType.ToString()); // Enum value
        writer.WriteEndElement();
        writer.WriteStartElement(null, "FinInstrmDtls", xmlNamespace );
        FinancialInstrumentDetails.Serialize(writer, xmlNamespace);
        writer.WriteEndElement();
        writer.WriteStartElement(null, "Qty", xmlNamespace );
        Quantity.Serialize(writer, xmlNamespace);
        writer.WriteEndElement();
        if (UnitsDetails is Unit3 UnitsDetailsValue)
        {
            writer.WriteStartElement(null, "UnitsDtls", xmlNamespace );
            UnitsDetailsValue.Serialize(writer, xmlNamespace);
            writer.WriteEndElement();
        }
        if (Rounding is RoundingDirection2Code RoundingValue)
        {
            writer.WriteStartElement(null, "Rndg", xmlNamespace );
            writer.WriteValue(RoundingValue.ToString()); // Enum value
            writer.WriteEndElement();
        }
        if (AveragePrice is IsoActiveOrHistoricCurrencyAnd13DecimalAmount AveragePriceValue)
        {
            writer.WriteStartElement(null, "AvrgPric", xmlNamespace );
            writer.WriteValue(SerializationFormatter.IsoActiveOrHistoricCurrencyAnd13DecimalAmount(AveragePriceValue)); // data type ActiveOrHistoricCurrencyAnd13DecimalAmount System.Decimal
            writer.WriteEndElement();
        }
        if (TransferCurrency is CurrencyCode TransferCurrencyValue)
        {
            writer.WriteStartElement(null, "TrfCcy", xmlNamespace );
            writer.WriteValue(TransferCurrencyValue.ToString()); // Enum value
            writer.WriteEndElement();
        }
        if (OwnAccountTransferIndicator is IsoYesNoIndicator OwnAccountTransferIndicatorValue)
        {
            writer.WriteStartElement(null, "OwnAcctTrfInd", xmlNamespace );
            writer.WriteValue(SerializationFormatter.IsoYesNoIndicator(OwnAccountTransferIndicatorValue)); // data type YesNoIndicator System.String
            writer.WriteEndElement();
        }
        if (NonStandardSettlementInformation is IsoMax350Text NonStandardSettlementInformationValue)
        {
            writer.WriteStartElement(null, "NonStdSttlmInf", xmlNamespace );
            writer.WriteValue(SerializationFormatter.IsoMax350Text(NonStandardSettlementInformationValue)); // data type Max350Text System.String
            writer.WriteEndElement();
        }
    }
    public static Transfer11 Deserialize(XElement element)
    {
        throw new NotImplementedException();
    }
}
